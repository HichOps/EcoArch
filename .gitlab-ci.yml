# Pipeline Master - EcoArch FinOps Platform V10
stages:
  - plan
  - test
  - finops
  - deploy

# â”€â”€ Variables globales â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
variables:
  TF_ROOT: "infra"
  GCP_WIF_PROVIDER: "projects/514436528658/locations/global/workloadIdentityPools/gitlab-pool/providers/gitlab-provider"
  GCP_SERVICE_ACCOUNT: "ecoarch-ci@ecoarch-mvp-1768828854.iam.gserviceaccount.com"
  TF_VAR_project_id: "ecoarch-mvp-1768828854"
  TF_VAR_region: "us-central1"
  TF_VAR_zone: "us-central1-a"
  TERRAFORM_VERSION: "1.10.0"
  PYTHON_VERSION: "3.11.10-slim"
  INFRACOST_VERSION: "v0.10.43"
  # Pip caching â€“ accÃ©lÃ¨re toutes les Ã©tapes Python
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  # GitLab HTTP Backend â€“ cohÃ©rent avec backend "http" {} dans main.tf
  TF_HTTP_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/ecoarch-infra"
  TF_HTTP_LOCK_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/ecoarch-infra/lock"
  TF_HTTP_UNLOCK_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state/ecoarch-infra/lock"
  TF_HTTP_USERNAME: "gitlab-ci-token"
  TF_HTTP_PASSWORD: "${CI_JOB_TOKEN}"
  TF_HTTP_LOCK_METHOD: "POST"
  TF_HTTP_UNLOCK_METHOD: "DELETE"
  TF_HTTP_RETRY_WAIT_MIN: "5"

# â”€â”€ Cache global pip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cache: &pip_cache
  key:
    files:
      - requirements-dev.txt
  paths:
    - .cache/pip
  policy: pull-push

# â”€â”€ Auth GCP (rÃ©utilisable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.gcp_auth:
  id_tokens:
    GCP_ID_TOKEN:
      aud: https://iam.googleapis.com/projects/514436528658/locations/global/workloadIdentityPools/gitlab-pool/providers/gitlab-provider
  before_script: &gcp_setup
    - echo "${GCP_ID_TOKEN}" > ${CI_PROJECT_DIR}/.google_id_token
    - |
      echo "{
        \"type\": \"external_account\",
        \"audience\": \"//iam.googleapis.com/projects/514436528658/locations/global/workloadIdentityPools/gitlab-pool/providers/gitlab-provider\",
        \"subject_token_type\": \"urn:ietf:params:oauth:token-type:jwt\",
        \"token_url\": \"https://sts.googleapis.com/v1/token\",
        \"service_account_impersonation_url\": \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${GCP_SERVICE_ACCOUNT}:generateAccessToken\",
        \"credential_source\": { \"file\": \"${CI_PROJECT_DIR}/.google_id_token\" }
      }" > ${CI_PROJECT_DIR}/.google_creds.json
    - export GOOGLE_APPLICATION_CREDENTIALS=${CI_PROJECT_DIR}/.google_creds.json

# â”€â”€ Template Python (dÃ©pendances dev) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.python_setup:
  image: python:${PYTHON_VERSION}
  cache: *pip_cache
  before_script:
    - pip install --quiet -r requirements-dev.txt
    - export PYTHONPATH=${CI_PROJECT_DIR}

# ============================================================
#  STAGE 1 : plan (Terraform)
# ============================================================
terraform_plan:
  extends: .gcp_auth
  stage: plan
  image:
    name: hashicorp/terraform:${TERRAFORM_VERSION}
    entrypoint: [""]
  script:
    - cd ${CI_PROJECT_DIR}/${TF_ROOT}
    - |
      terraform init -reconfigure \
        -backend-config="address=${TF_HTTP_ADDRESS}" \
        -backend-config="lock_address=${TF_HTTP_LOCK_ADDRESS}" \
        -backend-config="unlock_address=${TF_HTTP_UNLOCK_ADDRESS}" \
        -backend-config="username=${TF_HTTP_USERNAME}" \
        -backend-config="password=${TF_HTTP_PASSWORD}" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="retry_wait_min=5"
    - terraform plan -out=${CI_PROJECT_DIR}/tfplan.binary
    - terraform show -json ${CI_PROJECT_DIR}/tfplan.binary > ${CI_PROJECT_DIR}/plan.json
  artifacts:
    paths:
      - plan.json
      - tfplan.binary
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger"
      when: never
    - if: $CI_PIPELINE_SOURCE == "web"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================================
#  STAGE 2 : test (Pytest + Mypy)
# ============================================================
unit_tests:
  extends: .python_setup
  stage: test
  script:
    - echo "â”€â”€ Running pytest â”€â”€"
    - python -m pytest tests/ -v --tb=short --junitxml=report-junit.xml
  artifacts:
    when: always
    reports:
      junit: report-junit.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

static_analysis:
  extends: .python_setup
  stage: test
  script:
    - echo "â”€â”€ Running mypy â”€â”€"
    - mypy frontend/frontend/state.py --ignore-missing-imports --no-error-summary || true
    - echo "â”€â”€ Running ruff â”€â”€"
    - ruff check src/ tests/ --output-format=gitlab > ruff-report.json || true
  artifacts:
    when: always
    paths:
      - ruff-report.json
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================================
#  STAGE 3 : finops (Infracost + Budget Gate)
# ============================================================
infracost_analysis:
  extends: .gcp_auth
  stage: finops
  image: python:${PYTHON_VERSION}
  cache: *pip_cache
  before_script:
    - *gcp_setup
    - apt-get update && apt-get install -y curl unzip
    # Installation Infracost
    - curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh -s -- -v ${INFRACOST_VERSION}
    # Installation Terraform
    - |
      curl -fsSL https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip -o terraform.zip
      unzip terraform.zip
      chmod +x terraform
      mv terraform /usr/local/bin/
    # DÃ©pendances Python (depuis la racine du projet)
    - cd ${CI_PROJECT_DIR}
    - pip install --quiet -r requirements.txt
    - pip install --quiet -r requirements-dev.txt
    # VÃ©rification que pytest est disponible
    - python -m pytest --version
    - export PYTHONPATH=${CI_PROJECT_DIR}
  script:
    # Terraform plan (chemin absolu + backend HTTP cohÃ©rent avec main.tf)
    - cd ${CI_PROJECT_DIR}/${TF_ROOT}
    - |
      terraform init -reconfigure \
        -backend-config="address=${TF_HTTP_ADDRESS}" \
        -backend-config="lock_address=${TF_HTTP_LOCK_ADDRESS}" \
        -backend-config="unlock_address=${TF_HTTP_UNLOCK_ADDRESS}" \
        -backend-config="username=${TF_HTTP_USERNAME}" \
        -backend-config="password=${TF_HTTP_PASSWORD}" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="retry_wait_min=5"
    - terraform plan -out=finops_local.binary
    # Analyse Infracost (sortie en chemin absolu)
    - infracost breakdown --path finops_local.binary --format json --out-file ${CI_PROJECT_DIR}/infracost-report.json
    # Retour Ã  la racine (chemin absolu, plus de cd ..)
    - cd ${CI_PROJECT_DIR}
    # Rapport & Budget Gate
    - python src/parser.py > report.md
    - python src/gitlab_comment.py
    - python src/budget_gate.py
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger"
      when: never
    - if: $CI_PIPELINE_SOURCE == "web"
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  artifacts:
    paths:
      - infracost-report.json
      - report.md
    expire_in: 1 week

# ============================================================
#  STAGE 4 : deploy
# ============================================================

# â”€â”€ 4a. Cloud Run â€“ Build & Deploy de l'app EcoArch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# NÃ©cessite Docker-in-Docker : le job tourne dans un conteneur, sans dind
# il n'y a pas de daemon Docker pour exÃ©cuter "docker build".
cloud_run_deploy:
  stage: deploy
  image: google/cloud-sdk:slim
  services:
    - docker:24-dind
  variables:
    DOCKER_TLS_CERTDIR: ""       # connexion TCP simple au dind
    DOCKER_HOST: tcp://docker:2375
    SERVICE_NAME: "ecoarch-app"
    CLOUD_RUN_MEMORY: "1Gi"
    CLOUD_RUN_CPU: "1"
    CLOUD_RUN_PORT: "8000"
    CLOUD_RUN_MIN_INSTANCES: "0"
    CLOUD_RUN_MAX_INSTANCES: "4"
    CLOUD_RUN_CONCURRENCY: "80"
  id_tokens:
    GCP_ID_TOKEN:
      aud: https://iam.googleapis.com/projects/514436528658/locations/global/workloadIdentityPools/gitlab-pool/providers/gitlab-provider
  before_script:
    - *gcp_setup
    - apt-get update -qq && apt-get install -y -qq docker.io >/dev/null
  script:
    # â”€â”€ Auto-version â”€â”€
    - |
      CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
      MAJOR=$(echo "$CURRENT_TAG" | sed 's/^v//' | cut -d. -f1)
      MINOR=$(echo "$CURRENT_TAG" | sed 's/^v//' | cut -d. -f2)
      PATCH=$(echo "$CURRENT_TAG" | sed 's/^v//' | cut -d. -f3)
      PATCH=$((PATCH + 1))
      VERSION="v${MAJOR}.${MINOR}.${PATCH}"
      echo "VERSION=${VERSION}" | tee version.env
    # â”€â”€ Docker Build & Push â”€â”€
    - IMAGE="${TF_VAR_region}-docker.pkg.dev/${TF_VAR_project_id}/ecoarch/${SERVICE_NAME}"
    - gcloud auth configure-docker "${TF_VAR_region}-docker.pkg.dev" --quiet
    - docker build --platform linux/amd64 --build-arg VERSION="${VERSION}" -t "${IMAGE}:${VERSION}" -t "${IMAGE}:latest" .
    - docker push "${IMAGE}:${VERSION}"
    - docker push "${IMAGE}:latest"
    # â”€â”€ Cloud Run Deploy â”€â”€
    - |
      gcloud run deploy "${SERVICE_NAME}" \
        --project="${TF_VAR_project_id}" \
        --region="${TF_VAR_region}" \
        --image="${IMAGE}:${VERSION}" \
        --platform=managed \
        --allow-unauthenticated \
        --port="${CLOUD_RUN_PORT}" \
        --memory="${CLOUD_RUN_MEMORY}" \
        --cpu="${CLOUD_RUN_CPU}" \
        --min-instances="${CLOUD_RUN_MIN_INSTANCES}" \
        --max-instances="${CLOUD_RUN_MAX_INSTANCES}" \
        --concurrency="${CLOUD_RUN_CONCURRENCY}" \
        --set-env-vars="GCP_PROJECT_ID=${TF_VAR_project_id},APP_VERSION=${VERSION}" \
        --quiet
    # â”€â”€ Git tag â”€â”€
    - git tag -a "${VERSION}" -m "CI deploy ${VERSION}" || true
    - git push origin "${VERSION}" || true
    - echo "âœ… Cloud Run deploy ${VERSION} terminÃ©"
  artifacts:
    reports:
      dotenv: version.env
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger"
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: false
  environment:
    name: production
    action: start

# â”€â”€ 4b. Terraform Apply (dÃ©clenchÃ© via API Trigger) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ReÃ§oit : TF_VAR_architecture_json, ECOARCH_DEPLOYMENT_ID, ECOARCH_ACTION
terraform_deploy:
  stage: deploy
  image:
    name: hashicorp/terraform:${TERRAFORM_VERSION}
    entrypoint: [""]
  variables:
    ECOARCH_ACTION: "deploy"
    ECOARCH_DEPLOYMENT_ID: "manual"
  # TF_HTTP_* variables hÃ©ritÃ©es du scope global
  script:
    - echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    - echo "  EcoArch Deploy â€“ ID ${ECOARCH_DEPLOYMENT_ID}"
    - echo "  Action  ${ECOARCH_ACTION}"
    - echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    - cd ${CI_PROJECT_DIR}/${TF_ROOT}
    #
    # Initialisation avec GitLab HTTP Backend (reconfigure pour
    # ignorer le backend gcs dÃ©clarÃ© dans main.tf)
    #
    - |
      terraform init -reconfigure \
        -backend-config="address=${TF_HTTP_ADDRESS}" \
        -backend-config="lock_address=${TF_HTTP_LOCK_ADDRESS}" \
        -backend-config="unlock_address=${TF_HTTP_UNLOCK_ADDRESS}" \
        -backend-config="username=${TF_HTTP_USERNAME}" \
        -backend-config="password=${TF_HTTP_PASSWORD}" \
        -backend-config="lock_method=POST" \
        -backend-config="unlock_method=DELETE" \
        -backend-config="retry_wait_min=5"
    #
    # ExÃ©cution selon l'action demandÃ©e
    #
    - |
      if [ "${ECOARCH_ACTION}" = "destroy" ]; then
        echo "ğŸ”¥ Mode destruction"
        terraform destroy -auto-approve -input=false
      else
        echo "ğŸš€ Mode dÃ©ploiement"
        terraform plan -input=false -out=deploy.tfplan
        terraform apply -auto-approve -input=false deploy.tfplan
      fi
    - echo "âœ… Terraform ${ECOARCH_ACTION} terminÃ© avec succÃ¨s"
  rules:
    # DÃ©clenchÃ© uniquement via l'API Trigger (depuis l'app EcoArch)
    - if: $CI_PIPELINE_SOURCE == "trigger"
    # Ou manuellement depuis l'UI GitLab
    - if: $CI_PIPELINE_SOURCE == "web"
      when: manual
  environment:
    name: $ECOARCH_ACTION/$ECOARCH_DEPLOYMENT_ID
    action: start